// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `engine.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.Configuration)
pub struct Configuration {
    // message fields
    // @@protoc_insertion_point(field:scyna.Configuration.NatsUrl)
    pub NatsUrl: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.Configuration.NatsUsername)
    pub NatsUsername: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.Configuration.NatsPassword)
    pub NatsPassword: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.Configuration.DBHost)
    pub DBHost: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.Configuration.DBUsername)
    pub DBUsername: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.Configuration.DBPassword)
    pub DBPassword: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.Configuration.DBLocation)
    pub DBLocation: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.Configuration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Configuration {
    fn default() -> &'a Configuration {
        <Configuration as ::protobuf::Message>::default_instance()
    }
}

impl Configuration {
    pub fn new() -> Configuration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NatsUrl",
            |m: &Configuration| { &m.NatsUrl },
            |m: &mut Configuration| { &mut m.NatsUrl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NatsUsername",
            |m: &Configuration| { &m.NatsUsername },
            |m: &mut Configuration| { &mut m.NatsUsername },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NatsPassword",
            |m: &Configuration| { &m.NatsPassword },
            |m: &mut Configuration| { &mut m.NatsPassword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DBHost",
            |m: &Configuration| { &m.DBHost },
            |m: &mut Configuration| { &mut m.DBHost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DBUsername",
            |m: &Configuration| { &m.DBUsername },
            |m: &mut Configuration| { &mut m.DBUsername },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DBPassword",
            |m: &Configuration| { &m.DBPassword },
            |m: &mut Configuration| { &mut m.DBPassword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "DBLocation",
            |m: &Configuration| { &m.DBLocation },
            |m: &mut Configuration| { &mut m.DBLocation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Configuration>(
            "Configuration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Configuration {
    const NAME: &'static str = "Configuration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.NatsUrl = is.read_string()?;
                },
                18 => {
                    self.NatsUsername = is.read_string()?;
                },
                26 => {
                    self.NatsPassword = is.read_string()?;
                },
                34 => {
                    self.DBHost = is.read_string()?;
                },
                42 => {
                    self.DBUsername = is.read_string()?;
                },
                50 => {
                    self.DBPassword = is.read_string()?;
                },
                58 => {
                    self.DBLocation = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.NatsUrl.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.NatsUrl);
        }
        if !self.NatsUsername.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.NatsUsername);
        }
        if !self.NatsPassword.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.NatsPassword);
        }
        if !self.DBHost.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.DBHost);
        }
        if !self.DBUsername.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.DBUsername);
        }
        if !self.DBPassword.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.DBPassword);
        }
        if !self.DBLocation.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.DBLocation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.NatsUrl.is_empty() {
            os.write_string(1, &self.NatsUrl)?;
        }
        if !self.NatsUsername.is_empty() {
            os.write_string(2, &self.NatsUsername)?;
        }
        if !self.NatsPassword.is_empty() {
            os.write_string(3, &self.NatsPassword)?;
        }
        if !self.DBHost.is_empty() {
            os.write_string(4, &self.DBHost)?;
        }
        if !self.DBUsername.is_empty() {
            os.write_string(5, &self.DBUsername)?;
        }
        if !self.DBPassword.is_empty() {
            os.write_string(6, &self.DBPassword)?;
        }
        if !self.DBLocation.is_empty() {
            os.write_string(7, &self.DBLocation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Configuration {
        Configuration::new()
    }

    fn clear(&mut self) {
        self.NatsUrl.clear();
        self.NatsUsername.clear();
        self.NatsPassword.clear();
        self.DBHost.clear();
        self.DBUsername.clear();
        self.DBPassword.clear();
        self.DBLocation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Configuration {
        static instance: Configuration = Configuration {
            NatsUrl: ::std::string::String::new(),
            NatsUsername: ::std::string::String::new(),
            NatsPassword: ::std::string::String::new(),
            DBHost: ::std::string::String::new(),
            DBUsername: ::std::string::String::new(),
            DBPassword: ::std::string::String::new(),
            DBLocation: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Configuration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Configuration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Configuration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Configuration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// session
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.CreateSessionRequest)
pub struct CreateSessionRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.CreateSessionRequest.Module)
    pub Module: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.CreateSessionRequest.Secret)
    pub Secret: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.CreateSessionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSessionRequest {
    fn default() -> &'a CreateSessionRequest {
        <CreateSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateSessionRequest {
    pub fn new() -> CreateSessionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &CreateSessionRequest| { &m.Module },
            |m: &mut CreateSessionRequest| { &mut m.Module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Secret",
            |m: &CreateSessionRequest| { &m.Secret },
            |m: &mut CreateSessionRequest| { &mut m.Secret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSessionRequest>(
            "CreateSessionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSessionRequest {
    const NAME: &'static str = "CreateSessionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Module = is.read_string()?;
                },
                18 => {
                    self.Secret = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Module);
        }
        if !self.Secret.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Module.is_empty() {
            os.write_string(1, &self.Module)?;
        }
        if !self.Secret.is_empty() {
            os.write_string(2, &self.Secret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSessionRequest {
        CreateSessionRequest::new()
    }

    fn clear(&mut self) {
        self.Module.clear();
        self.Secret.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSessionRequest {
        static instance: CreateSessionRequest = CreateSessionRequest {
            Module: ::std::string::String::new(),
            Secret: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSessionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSessionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSessionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.CreateSessionResponse)
pub struct CreateSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:scyna.CreateSessionResponse.SessionID)
    pub SessionID: u64,
    // @@protoc_insertion_point(field:scyna.CreateSessionResponse.Config)
    pub Config: ::protobuf::MessageField<Configuration>,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.CreateSessionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateSessionResponse {
    fn default() -> &'a CreateSessionResponse {
        <CreateSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateSessionResponse {
    pub fn new() -> CreateSessionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SessionID",
            |m: &CreateSessionResponse| { &m.SessionID },
            |m: &mut CreateSessionResponse| { &mut m.SessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Configuration>(
            "Config",
            |m: &CreateSessionResponse| { &m.Config },
            |m: &mut CreateSessionResponse| { &mut m.Config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateSessionResponse>(
            "CreateSessionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateSessionResponse {
    const NAME: &'static str = "CreateSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.SessionID = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.Config)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.SessionID != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.SessionID);
        }
        if let Some(v) = self.Config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.SessionID != 0 {
            os.write_uint64(1, self.SessionID)?;
        }
        if let Some(v) = self.Config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateSessionResponse {
        CreateSessionResponse::new()
    }

    fn clear(&mut self) {
        self.SessionID = 0;
        self.Config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateSessionResponse {
        static instance: CreateSessionResponse = CreateSessionResponse {
            SessionID: 0,
            Config: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateSessionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateSessionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateSessionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.EndSessionSignal)
pub struct EndSessionSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.EndSessionSignal.ID)
    pub ID: u64,
    // @@protoc_insertion_point(field:scyna.EndSessionSignal.Code)
    pub Code: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.EndSessionSignal.Module)
    pub Module: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.EndSessionSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndSessionSignal {
    fn default() -> &'a EndSessionSignal {
        <EndSessionSignal as ::protobuf::Message>::default_instance()
    }
}

impl EndSessionSignal {
    pub fn new() -> EndSessionSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ID",
            |m: &EndSessionSignal| { &m.ID },
            |m: &mut EndSessionSignal| { &mut m.ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Code",
            |m: &EndSessionSignal| { &m.Code },
            |m: &mut EndSessionSignal| { &mut m.Code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &EndSessionSignal| { &m.Module },
            |m: &mut EndSessionSignal| { &mut m.Module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndSessionSignal>(
            "EndSessionSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndSessionSignal {
    const NAME: &'static str = "EndSessionSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ID = is.read_uint64()?;
                },
                18 => {
                    self.Code = is.read_string()?;
                },
                26 => {
                    self.Module = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.ID);
        }
        if !self.Code.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Code);
        }
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Module);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        if !self.Code.is_empty() {
            os.write_string(2, &self.Code)?;
        }
        if !self.Module.is_empty() {
            os.write_string(3, &self.Module)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndSessionSignal {
        EndSessionSignal::new()
    }

    fn clear(&mut self) {
        self.ID = 0;
        self.Code.clear();
        self.Module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndSessionSignal {
        static instance: EndSessionSignal = EndSessionSignal {
            ID: 0,
            Code: ::std::string::String::new(),
            Module: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndSessionSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndSessionSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndSessionSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndSessionSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.UpdateSessionSignal)
pub struct UpdateSessionSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.UpdateSessionSignal.ID)
    pub ID: u64,
    // @@protoc_insertion_point(field:scyna.UpdateSessionSignal.Module)
    pub Module: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.UpdateSessionSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateSessionSignal {
    fn default() -> &'a UpdateSessionSignal {
        <UpdateSessionSignal as ::protobuf::Message>::default_instance()
    }
}

impl UpdateSessionSignal {
    pub fn new() -> UpdateSessionSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ID",
            |m: &UpdateSessionSignal| { &m.ID },
            |m: &mut UpdateSessionSignal| { &mut m.ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &UpdateSessionSignal| { &m.Module },
            |m: &mut UpdateSessionSignal| { &mut m.Module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateSessionSignal>(
            "UpdateSessionSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateSessionSignal {
    const NAME: &'static str = "UpdateSessionSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ID = is.read_uint64()?;
                },
                18 => {
                    self.Module = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.ID);
        }
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Module);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        if !self.Module.is_empty() {
            os.write_string(2, &self.Module)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateSessionSignal {
        UpdateSessionSignal::new()
    }

    fn clear(&mut self) {
        self.ID = 0;
        self.Module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateSessionSignal {
        static instance: UpdateSessionSignal = UpdateSessionSignal {
            ID: 0,
            Module: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateSessionSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateSessionSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateSessionSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateSessionSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// GENERATOR
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.GetIDRequest)
pub struct GetIDRequest {
    // special fields
    // @@protoc_insertion_point(special_field:scyna.GetIDRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetIDRequest {
    fn default() -> &'a GetIDRequest {
        <GetIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIDRequest {
    pub fn new() -> GetIDRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetIDRequest>(
            "GetIDRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetIDRequest {
    const NAME: &'static str = "GetIDRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetIDRequest {
        GetIDRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetIDRequest {
        static instance: GetIDRequest = GetIDRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetIDRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetIDRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetIDRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIDRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.GetIDResponse)
pub struct GetIDResponse {
    // message fields
    // @@protoc_insertion_point(field:scyna.GetIDResponse.prefix)
    pub prefix: u32,
    // @@protoc_insertion_point(field:scyna.GetIDResponse.start)
    pub start: u64,
    // @@protoc_insertion_point(field:scyna.GetIDResponse.end)
    pub end: u64,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.GetIDResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetIDResponse {
    fn default() -> &'a GetIDResponse {
        <GetIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIDResponse {
    pub fn new() -> GetIDResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &GetIDResponse| { &m.prefix },
            |m: &mut GetIDResponse| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start",
            |m: &GetIDResponse| { &m.start },
            |m: &mut GetIDResponse| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end",
            |m: &GetIDResponse| { &m.end },
            |m: &mut GetIDResponse| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetIDResponse>(
            "GetIDResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetIDResponse {
    const NAME: &'static str = "GetIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prefix = is.read_uint32()?;
                },
                16 => {
                    self.start = is.read_uint64()?;
                },
                24 => {
                    self.end = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.prefix != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.prefix);
        }
        if self.start != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.start);
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.prefix != 0 {
            os.write_uint32(1, self.prefix)?;
        }
        if self.start != 0 {
            os.write_uint64(2, self.start)?;
        }
        if self.end != 0 {
            os.write_uint64(3, self.end)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetIDResponse {
        GetIDResponse::new()
    }

    fn clear(&mut self) {
        self.prefix = 0;
        self.start = 0;
        self.end = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetIDResponse {
        static instance: GetIDResponse = GetIDResponse {
            prefix: 0,
            start: 0,
            end: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetIDResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetIDResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetIDResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIDResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.GetSNRequest)
pub struct GetSNRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.GetSNRequest.key)
    pub key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.GetSNRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSNRequest {
    fn default() -> &'a GetSNRequest {
        <GetSNRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetSNRequest {
    pub fn new() -> GetSNRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &GetSNRequest| { &m.key },
            |m: &mut GetSNRequest| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSNRequest>(
            "GetSNRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSNRequest {
    const NAME: &'static str = "GetSNRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSNRequest {
        GetSNRequest::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSNRequest {
        static instance: GetSNRequest = GetSNRequest {
            key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSNRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSNRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSNRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSNRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.GetSNResponse)
pub struct GetSNResponse {
    // message fields
    // @@protoc_insertion_point(field:scyna.GetSNResponse.prefix)
    pub prefix: u32,
    // @@protoc_insertion_point(field:scyna.GetSNResponse.start)
    pub start: u64,
    // @@protoc_insertion_point(field:scyna.GetSNResponse.end)
    pub end: u64,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.GetSNResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetSNResponse {
    fn default() -> &'a GetSNResponse {
        <GetSNResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetSNResponse {
    pub fn new() -> GetSNResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &GetSNResponse| { &m.prefix },
            |m: &mut GetSNResponse| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start",
            |m: &GetSNResponse| { &m.start },
            |m: &mut GetSNResponse| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end",
            |m: &GetSNResponse| { &m.end },
            |m: &mut GetSNResponse| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetSNResponse>(
            "GetSNResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetSNResponse {
    const NAME: &'static str = "GetSNResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.prefix = is.read_uint32()?;
                },
                16 => {
                    self.start = is.read_uint64()?;
                },
                24 => {
                    self.end = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.prefix != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.prefix);
        }
        if self.start != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.start);
        }
        if self.end != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.end);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.prefix != 0 {
            os.write_uint32(1, self.prefix)?;
        }
        if self.start != 0 {
            os.write_uint64(2, self.start)?;
        }
        if self.end != 0 {
            os.write_uint64(3, self.end)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetSNResponse {
        GetSNResponse::new()
    }

    fn clear(&mut self) {
        self.prefix = 0;
        self.start = 0;
        self.end = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetSNResponse {
        static instance: GetSNResponse = GetSNResponse {
            prefix: 0,
            start: 0,
            end: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetSNResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetSNResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetSNResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetSNResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// LOG
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.LogCreatedSignal)
pub struct LogCreatedSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.LogCreatedSignal.Time)
    pub Time: u64,
    // @@protoc_insertion_point(field:scyna.LogCreatedSignal.Level)
    pub Level: u32,
    // @@protoc_insertion_point(field:scyna.LogCreatedSignal.Text)
    pub Text: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.LogCreatedSignal.ID)
    pub ID: u64,
    // @@protoc_insertion_point(field:scyna.LogCreatedSignal.SEQ)
    pub SEQ: u64,
    // @@protoc_insertion_point(field:scyna.LogCreatedSignal.Session)
    pub Session: bool,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.LogCreatedSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogCreatedSignal {
    fn default() -> &'a LogCreatedSignal {
        <LogCreatedSignal as ::protobuf::Message>::default_instance()
    }
}

impl LogCreatedSignal {
    pub fn new() -> LogCreatedSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Time",
            |m: &LogCreatedSignal| { &m.Time },
            |m: &mut LogCreatedSignal| { &mut m.Time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Level",
            |m: &LogCreatedSignal| { &m.Level },
            |m: &mut LogCreatedSignal| { &mut m.Level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Text",
            |m: &LogCreatedSignal| { &m.Text },
            |m: &mut LogCreatedSignal| { &mut m.Text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ID",
            |m: &LogCreatedSignal| { &m.ID },
            |m: &mut LogCreatedSignal| { &mut m.ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SEQ",
            |m: &LogCreatedSignal| { &m.SEQ },
            |m: &mut LogCreatedSignal| { &mut m.SEQ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Session",
            |m: &LogCreatedSignal| { &m.Session },
            |m: &mut LogCreatedSignal| { &mut m.Session },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogCreatedSignal>(
            "LogCreatedSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogCreatedSignal {
    const NAME: &'static str = "LogCreatedSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.Time = is.read_uint64()?;
                },
                16 => {
                    self.Level = is.read_uint32()?;
                },
                26 => {
                    self.Text = is.read_string()?;
                },
                32 => {
                    self.ID = is.read_uint64()?;
                },
                40 => {
                    self.SEQ = is.read_uint64()?;
                },
                48 => {
                    self.Session = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.Time != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.Time);
        }
        if self.Level != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.Level);
        }
        if !self.Text.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Text);
        }
        if self.ID != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.ID);
        }
        if self.SEQ != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.SEQ);
        }
        if self.Session != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.Time != 0 {
            os.write_uint64(1, self.Time)?;
        }
        if self.Level != 0 {
            os.write_uint32(2, self.Level)?;
        }
        if !self.Text.is_empty() {
            os.write_string(3, &self.Text)?;
        }
        if self.ID != 0 {
            os.write_uint64(4, self.ID)?;
        }
        if self.SEQ != 0 {
            os.write_uint64(5, self.SEQ)?;
        }
        if self.Session != false {
            os.write_bool(6, self.Session)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogCreatedSignal {
        LogCreatedSignal::new()
    }

    fn clear(&mut self) {
        self.Time = 0;
        self.Level = 0;
        self.Text.clear();
        self.ID = 0;
        self.SEQ = 0;
        self.Session = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogCreatedSignal {
        static instance: LogCreatedSignal = LogCreatedSignal {
            Time: 0,
            Level: 0,
            Text: ::std::string::String::new(),
            ID: 0,
            SEQ: 0,
            Session: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogCreatedSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogCreatedSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogCreatedSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogCreatedSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.TraceCreatedSignal)
pub struct TraceCreatedSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.ID)
    pub ID: u64,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.ParentID)
    pub ParentID: u64,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.Type)
    pub Type: u32,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.Time)
    pub Time: u64,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.Duration)
    pub Duration: u64,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.Path)
    pub Path: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.Source)
    pub Source: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.SessionID)
    pub SessionID: u64,
    // @@protoc_insertion_point(field:scyna.TraceCreatedSignal.Status)
    pub Status: i32,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.TraceCreatedSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TraceCreatedSignal {
    fn default() -> &'a TraceCreatedSignal {
        <TraceCreatedSignal as ::protobuf::Message>::default_instance()
    }
}

impl TraceCreatedSignal {
    pub fn new() -> TraceCreatedSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ID",
            |m: &TraceCreatedSignal| { &m.ID },
            |m: &mut TraceCreatedSignal| { &mut m.ID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ParentID",
            |m: &TraceCreatedSignal| { &m.ParentID },
            |m: &mut TraceCreatedSignal| { &mut m.ParentID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Type",
            |m: &TraceCreatedSignal| { &m.Type },
            |m: &mut TraceCreatedSignal| { &mut m.Type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Time",
            |m: &TraceCreatedSignal| { &m.Time },
            |m: &mut TraceCreatedSignal| { &mut m.Time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Duration",
            |m: &TraceCreatedSignal| { &m.Duration },
            |m: &mut TraceCreatedSignal| { &mut m.Duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Path",
            |m: &TraceCreatedSignal| { &m.Path },
            |m: &mut TraceCreatedSignal| { &mut m.Path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Source",
            |m: &TraceCreatedSignal| { &m.Source },
            |m: &mut TraceCreatedSignal| { &mut m.Source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SessionID",
            |m: &TraceCreatedSignal| { &m.SessionID },
            |m: &mut TraceCreatedSignal| { &mut m.SessionID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Status",
            |m: &TraceCreatedSignal| { &m.Status },
            |m: &mut TraceCreatedSignal| { &mut m.Status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TraceCreatedSignal>(
            "TraceCreatedSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TraceCreatedSignal {
    const NAME: &'static str = "TraceCreatedSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ID = is.read_uint64()?;
                },
                16 => {
                    self.ParentID = is.read_uint64()?;
                },
                24 => {
                    self.Type = is.read_uint32()?;
                },
                32 => {
                    self.Time = is.read_uint64()?;
                },
                40 => {
                    self.Duration = is.read_uint64()?;
                },
                50 => {
                    self.Path = is.read_string()?;
                },
                58 => {
                    self.Source = is.read_string()?;
                },
                64 => {
                    self.SessionID = is.read_uint64()?;
                },
                72 => {
                    self.Status = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ID != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.ID);
        }
        if self.ParentID != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.ParentID);
        }
        if self.Type != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.Type);
        }
        if self.Time != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.Time);
        }
        if self.Duration != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.Duration);
        }
        if !self.Path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Path);
        }
        if !self.Source.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.Source);
        }
        if self.SessionID != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.SessionID);
        }
        if self.Status != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.Status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ID != 0 {
            os.write_uint64(1, self.ID)?;
        }
        if self.ParentID != 0 {
            os.write_uint64(2, self.ParentID)?;
        }
        if self.Type != 0 {
            os.write_uint32(3, self.Type)?;
        }
        if self.Time != 0 {
            os.write_uint64(4, self.Time)?;
        }
        if self.Duration != 0 {
            os.write_uint64(5, self.Duration)?;
        }
        if !self.Path.is_empty() {
            os.write_string(6, &self.Path)?;
        }
        if !self.Source.is_empty() {
            os.write_string(7, &self.Source)?;
        }
        if self.SessionID != 0 {
            os.write_uint64(8, self.SessionID)?;
        }
        if self.Status != 0 {
            os.write_int32(9, self.Status)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TraceCreatedSignal {
        TraceCreatedSignal::new()
    }

    fn clear(&mut self) {
        self.ID = 0;
        self.ParentID = 0;
        self.Type = 0;
        self.Time = 0;
        self.Duration = 0;
        self.Path.clear();
        self.Source.clear();
        self.SessionID = 0;
        self.Status = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TraceCreatedSignal {
        static instance: TraceCreatedSignal = TraceCreatedSignal {
            ID: 0,
            ParentID: 0,
            Type: 0,
            Time: 0,
            Duration: 0,
            Path: ::std::string::String::new(),
            Source: ::std::string::String::new(),
            SessionID: 0,
            Status: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TraceCreatedSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TraceCreatedSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TraceCreatedSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TraceCreatedSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.TagCreatedSignal)
pub struct TagCreatedSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.TagCreatedSignal.TraceID)
    pub TraceID: u64,
    // @@protoc_insertion_point(field:scyna.TagCreatedSignal.Key)
    pub Key: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.TagCreatedSignal.Value)
    pub Value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.TagCreatedSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TagCreatedSignal {
    fn default() -> &'a TagCreatedSignal {
        <TagCreatedSignal as ::protobuf::Message>::default_instance()
    }
}

impl TagCreatedSignal {
    pub fn new() -> TagCreatedSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TraceID",
            |m: &TagCreatedSignal| { &m.TraceID },
            |m: &mut TagCreatedSignal| { &mut m.TraceID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Key",
            |m: &TagCreatedSignal| { &m.Key },
            |m: &mut TagCreatedSignal| { &mut m.Key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Value",
            |m: &TagCreatedSignal| { &m.Value },
            |m: &mut TagCreatedSignal| { &mut m.Value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TagCreatedSignal>(
            "TagCreatedSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TagCreatedSignal {
    const NAME: &'static str = "TagCreatedSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.TraceID = is.read_uint64()?;
                },
                18 => {
                    self.Key = is.read_string()?;
                },
                26 => {
                    self.Value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.TraceID != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.TraceID);
        }
        if !self.Key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Key);
        }
        if !self.Value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.TraceID != 0 {
            os.write_uint64(1, self.TraceID)?;
        }
        if !self.Key.is_empty() {
            os.write_string(2, &self.Key)?;
        }
        if !self.Value.is_empty() {
            os.write_string(3, &self.Value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TagCreatedSignal {
        TagCreatedSignal::new()
    }

    fn clear(&mut self) {
        self.TraceID = 0;
        self.Key.clear();
        self.Value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TagCreatedSignal {
        static instance: TagCreatedSignal = TagCreatedSignal {
            TraceID: 0,
            Key: ::std::string::String::new(),
            Value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TagCreatedSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TagCreatedSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TagCreatedSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagCreatedSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.EndpointDoneSignal)
pub struct EndpointDoneSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.EndpointDoneSignal.TraceID)
    pub TraceID: u64,
    // @@protoc_insertion_point(field:scyna.EndpointDoneSignal.Response)
    pub Response: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.EndpointDoneSignal.Request)
    pub Request: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.EndpointDoneSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EndpointDoneSignal {
    fn default() -> &'a EndpointDoneSignal {
        <EndpointDoneSignal as ::protobuf::Message>::default_instance()
    }
}

impl EndpointDoneSignal {
    pub fn new() -> EndpointDoneSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TraceID",
            |m: &EndpointDoneSignal| { &m.TraceID },
            |m: &mut EndpointDoneSignal| { &mut m.TraceID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Response",
            |m: &EndpointDoneSignal| { &m.Response },
            |m: &mut EndpointDoneSignal| { &mut m.Response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Request",
            |m: &EndpointDoneSignal| { &m.Request },
            |m: &mut EndpointDoneSignal| { &mut m.Request },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EndpointDoneSignal>(
            "EndpointDoneSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EndpointDoneSignal {
    const NAME: &'static str = "EndpointDoneSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.TraceID = is.read_uint64()?;
                },
                18 => {
                    self.Response = is.read_string()?;
                },
                26 => {
                    self.Request = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.TraceID != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.TraceID);
        }
        if !self.Response.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Response);
        }
        if !self.Request.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Request);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.TraceID != 0 {
            os.write_uint64(1, self.TraceID)?;
        }
        if !self.Response.is_empty() {
            os.write_string(2, &self.Response)?;
        }
        if !self.Request.is_empty() {
            os.write_string(3, &self.Request)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EndpointDoneSignal {
        EndpointDoneSignal::new()
    }

    fn clear(&mut self) {
        self.TraceID = 0;
        self.Response.clear();
        self.Request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EndpointDoneSignal {
        static instance: EndpointDoneSignal = EndpointDoneSignal {
            TraceID: 0,
            Response: ::std::string::String::new(),
            Request: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EndpointDoneSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EndpointDoneSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EndpointDoneSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointDoneSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// SETTING
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.WriteSettingRequest)
pub struct WriteSettingRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.WriteSettingRequest.Module)
    pub Module: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.WriteSettingRequest.Key)
    pub Key: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.WriteSettingRequest.Value)
    pub Value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.WriteSettingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSettingRequest {
    fn default() -> &'a WriteSettingRequest {
        <WriteSettingRequest as ::protobuf::Message>::default_instance()
    }
}

impl WriteSettingRequest {
    pub fn new() -> WriteSettingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &WriteSettingRequest| { &m.Module },
            |m: &mut WriteSettingRequest| { &mut m.Module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Key",
            |m: &WriteSettingRequest| { &m.Key },
            |m: &mut WriteSettingRequest| { &mut m.Key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Value",
            |m: &WriteSettingRequest| { &m.Value },
            |m: &mut WriteSettingRequest| { &mut m.Value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSettingRequest>(
            "WriteSettingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSettingRequest {
    const NAME: &'static str = "WriteSettingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Module = is.read_string()?;
                },
                18 => {
                    self.Key = is.read_string()?;
                },
                26 => {
                    self.Value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Module);
        }
        if !self.Key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Key);
        }
        if !self.Value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Module.is_empty() {
            os.write_string(1, &self.Module)?;
        }
        if !self.Key.is_empty() {
            os.write_string(2, &self.Key)?;
        }
        if !self.Value.is_empty() {
            os.write_string(3, &self.Value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSettingRequest {
        WriteSettingRequest::new()
    }

    fn clear(&mut self) {
        self.Module.clear();
        self.Key.clear();
        self.Value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSettingRequest {
        static instance: WriteSettingRequest = WriteSettingRequest {
            Module: ::std::string::String::new(),
            Key: ::std::string::String::new(),
            Value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSettingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSettingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSettingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSettingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.ReadSettingRequest)
pub struct ReadSettingRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.ReadSettingRequest.Module)
    pub Module: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.ReadSettingRequest.Key)
    pub Key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.ReadSettingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadSettingRequest {
    fn default() -> &'a ReadSettingRequest {
        <ReadSettingRequest as ::protobuf::Message>::default_instance()
    }
}

impl ReadSettingRequest {
    pub fn new() -> ReadSettingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &ReadSettingRequest| { &m.Module },
            |m: &mut ReadSettingRequest| { &mut m.Module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Key",
            |m: &ReadSettingRequest| { &m.Key },
            |m: &mut ReadSettingRequest| { &mut m.Key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadSettingRequest>(
            "ReadSettingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadSettingRequest {
    const NAME: &'static str = "ReadSettingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Module = is.read_string()?;
                },
                18 => {
                    self.Key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Module);
        }
        if !self.Key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Module.is_empty() {
            os.write_string(1, &self.Module)?;
        }
        if !self.Key.is_empty() {
            os.write_string(2, &self.Key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadSettingRequest {
        ReadSettingRequest::new()
    }

    fn clear(&mut self) {
        self.Module.clear();
        self.Key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadSettingRequest {
        static instance: ReadSettingRequest = ReadSettingRequest {
            Module: ::std::string::String::new(),
            Key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadSettingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadSettingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadSettingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadSettingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.ReadSettingResponse)
pub struct ReadSettingResponse {
    // message fields
    // @@protoc_insertion_point(field:scyna.ReadSettingResponse.Value)
    pub Value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.ReadSettingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ReadSettingResponse {
    fn default() -> &'a ReadSettingResponse {
        <ReadSettingResponse as ::protobuf::Message>::default_instance()
    }
}

impl ReadSettingResponse {
    pub fn new() -> ReadSettingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Value",
            |m: &ReadSettingResponse| { &m.Value },
            |m: &mut ReadSettingResponse| { &mut m.Value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReadSettingResponse>(
            "ReadSettingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ReadSettingResponse {
    const NAME: &'static str = "ReadSettingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Value.is_empty() {
            os.write_string(1, &self.Value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ReadSettingResponse {
        ReadSettingResponse::new()
    }

    fn clear(&mut self) {
        self.Value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ReadSettingResponse {
        static instance: ReadSettingResponse = ReadSettingResponse {
            Value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ReadSettingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ReadSettingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ReadSettingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReadSettingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.SettingUpdatedSignal)
pub struct SettingUpdatedSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.SettingUpdatedSignal.Module)
    pub Module: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.SettingUpdatedSignal.Key)
    pub Key: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.SettingUpdatedSignal.Value)
    pub Value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.SettingUpdatedSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SettingUpdatedSignal {
    fn default() -> &'a SettingUpdatedSignal {
        <SettingUpdatedSignal as ::protobuf::Message>::default_instance()
    }
}

impl SettingUpdatedSignal {
    pub fn new() -> SettingUpdatedSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &SettingUpdatedSignal| { &m.Module },
            |m: &mut SettingUpdatedSignal| { &mut m.Module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Key",
            |m: &SettingUpdatedSignal| { &m.Key },
            |m: &mut SettingUpdatedSignal| { &mut m.Key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Value",
            |m: &SettingUpdatedSignal| { &m.Value },
            |m: &mut SettingUpdatedSignal| { &mut m.Value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SettingUpdatedSignal>(
            "SettingUpdatedSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SettingUpdatedSignal {
    const NAME: &'static str = "SettingUpdatedSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Module = is.read_string()?;
                },
                18 => {
                    self.Key = is.read_string()?;
                },
                26 => {
                    self.Value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Module);
        }
        if !self.Key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Key);
        }
        if !self.Value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Module.is_empty() {
            os.write_string(1, &self.Module)?;
        }
        if !self.Key.is_empty() {
            os.write_string(2, &self.Key)?;
        }
        if !self.Value.is_empty() {
            os.write_string(3, &self.Value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SettingUpdatedSignal {
        SettingUpdatedSignal::new()
    }

    fn clear(&mut self) {
        self.Module.clear();
        self.Key.clear();
        self.Value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SettingUpdatedSignal {
        static instance: SettingUpdatedSignal = SettingUpdatedSignal {
            Module: ::std::string::String::new(),
            Key: ::std::string::String::new(),
            Value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SettingUpdatedSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SettingUpdatedSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SettingUpdatedSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SettingUpdatedSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.SettingRemovedSignal)
pub struct SettingRemovedSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.SettingRemovedSignal.Module)
    pub Module: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.SettingRemovedSignal.Key)
    pub Key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.SettingRemovedSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SettingRemovedSignal {
    fn default() -> &'a SettingRemovedSignal {
        <SettingRemovedSignal as ::protobuf::Message>::default_instance()
    }
}

impl SettingRemovedSignal {
    pub fn new() -> SettingRemovedSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &SettingRemovedSignal| { &m.Module },
            |m: &mut SettingRemovedSignal| { &mut m.Module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Key",
            |m: &SettingRemovedSignal| { &m.Key },
            |m: &mut SettingRemovedSignal| { &mut m.Key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SettingRemovedSignal>(
            "SettingRemovedSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SettingRemovedSignal {
    const NAME: &'static str = "SettingRemovedSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Module = is.read_string()?;
                },
                18 => {
                    self.Key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Module);
        }
        if !self.Key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Module.is_empty() {
            os.write_string(1, &self.Module)?;
        }
        if !self.Key.is_empty() {
            os.write_string(2, &self.Key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SettingRemovedSignal {
        SettingRemovedSignal::new()
    }

    fn clear(&mut self) {
        self.Module.clear();
        self.Key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SettingRemovedSignal {
        static instance: SettingRemovedSignal = SettingRemovedSignal {
            Module: ::std::string::String::new(),
            Key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SettingRemovedSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SettingRemovedSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SettingRemovedSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SettingRemovedSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.RemoveSettingRequest)
pub struct RemoveSettingRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.RemoveSettingRequest.Module)
    pub Module: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.RemoveSettingRequest.Key)
    pub Key: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.RemoveSettingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveSettingRequest {
    fn default() -> &'a RemoveSettingRequest {
        <RemoveSettingRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemoveSettingRequest {
    pub fn new() -> RemoveSettingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Module",
            |m: &RemoveSettingRequest| { &m.Module },
            |m: &mut RemoveSettingRequest| { &mut m.Module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Key",
            |m: &RemoveSettingRequest| { &m.Key },
            |m: &mut RemoveSettingRequest| { &mut m.Key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveSettingRequest>(
            "RemoveSettingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveSettingRequest {
    const NAME: &'static str = "RemoveSettingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Module = is.read_string()?;
                },
                18 => {
                    self.Key = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Module.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Module);
        }
        if !self.Key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Module.is_empty() {
            os.write_string(1, &self.Module)?;
        }
        if !self.Key.is_empty() {
            os.write_string(2, &self.Key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveSettingRequest {
        RemoveSettingRequest::new()
    }

    fn clear(&mut self) {
        self.Module.clear();
        self.Key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveSettingRequest {
        static instance: RemoveSettingRequest = RemoveSettingRequest {
            Module: ::std::string::String::new(),
            Key: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveSettingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveSettingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveSettingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveSettingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// CALL
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.WriteCallSignal)
pub struct WriteCallSignal {
    // message fields
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.id)
    pub id: u64,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.source)
    pub source: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.caller_id)
    pub caller_id: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.session_id)
    pub session_id: u64,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.duration)
    pub duration: u32,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.request)
    pub request: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.response)
    pub response: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.status)
    pub status: u32,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.time)
    pub time: u64,
    // @@protoc_insertion_point(field:scyna.WriteCallSignal.day)
    pub day: u32,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.WriteCallSignal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteCallSignal {
    fn default() -> &'a WriteCallSignal {
        <WriteCallSignal as ::protobuf::Message>::default_instance()
    }
}

impl WriteCallSignal {
    pub fn new() -> WriteCallSignal {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &WriteCallSignal| { &m.id },
            |m: &mut WriteCallSignal| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source",
            |m: &WriteCallSignal| { &m.source },
            |m: &mut WriteCallSignal| { &mut m.source },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "caller_id",
            |m: &WriteCallSignal| { &m.caller_id },
            |m: &mut WriteCallSignal| { &mut m.caller_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "session_id",
            |m: &WriteCallSignal| { &m.session_id },
            |m: &mut WriteCallSignal| { &mut m.session_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &WriteCallSignal| { &m.duration },
            |m: &mut WriteCallSignal| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request",
            |m: &WriteCallSignal| { &m.request },
            |m: &mut WriteCallSignal| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response",
            |m: &WriteCallSignal| { &m.response },
            |m: &mut WriteCallSignal| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &WriteCallSignal| { &m.status },
            |m: &mut WriteCallSignal| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &WriteCallSignal| { &m.time },
            |m: &mut WriteCallSignal| { &mut m.time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "day",
            |m: &WriteCallSignal| { &m.day },
            |m: &mut WriteCallSignal| { &mut m.day },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteCallSignal>(
            "WriteCallSignal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteCallSignal {
    const NAME: &'static str = "WriteCallSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_uint64()?;
                },
                18 => {
                    self.source = is.read_string()?;
                },
                26 => {
                    self.caller_id = is.read_string()?;
                },
                32 => {
                    self.session_id = is.read_uint64()?;
                },
                40 => {
                    self.duration = is.read_uint32()?;
                },
                50 => {
                    self.request = is.read_bytes()?;
                },
                58 => {
                    self.response = is.read_bytes()?;
                },
                64 => {
                    self.status = is.read_uint32()?;
                },
                72 => {
                    self.time = is.read_uint64()?;
                },
                80 => {
                    self.day = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.id);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.source);
        }
        if !self.caller_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.caller_id);
        }
        if self.session_id != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.session_id);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.duration);
        }
        if !self.request.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.request);
        }
        if !self.response.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.response);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.status);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.time);
        }
        if self.day != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.day);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if !self.source.is_empty() {
            os.write_string(2, &self.source)?;
        }
        if !self.caller_id.is_empty() {
            os.write_string(3, &self.caller_id)?;
        }
        if self.session_id != 0 {
            os.write_uint64(4, self.session_id)?;
        }
        if self.duration != 0 {
            os.write_uint32(5, self.duration)?;
        }
        if !self.request.is_empty() {
            os.write_bytes(6, &self.request)?;
        }
        if !self.response.is_empty() {
            os.write_bytes(7, &self.response)?;
        }
        if self.status != 0 {
            os.write_uint32(8, self.status)?;
        }
        if self.time != 0 {
            os.write_uint64(9, self.time)?;
        }
        if self.day != 0 {
            os.write_uint32(10, self.day)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteCallSignal {
        WriteCallSignal::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.source.clear();
        self.caller_id.clear();
        self.session_id = 0;
        self.duration = 0;
        self.request.clear();
        self.response.clear();
        self.status = 0;
        self.time = 0;
        self.day = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteCallSignal {
        static instance: WriteCallSignal = WriteCallSignal {
            id: 0,
            source: ::std::string::String::new(),
            caller_id: ::std::string::String::new(),
            session_id: 0,
            duration: 0,
            request: ::std::vec::Vec::new(),
            response: ::std::vec::Vec::new(),
            status: 0,
            time: 0,
            day: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteCallSignal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteCallSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteCallSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteCallSignal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Authentication
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.CreateAuthRequest)
pub struct CreateAuthRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.CreateAuthRequest.UID)
    pub UID: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.CreateAuthRequest.Apps)
    pub Apps: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.CreateAuthRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateAuthRequest {
    fn default() -> &'a CreateAuthRequest {
        <CreateAuthRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateAuthRequest {
    pub fn new() -> CreateAuthRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UID",
            |m: &CreateAuthRequest| { &m.UID },
            |m: &mut CreateAuthRequest| { &mut m.UID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "Apps",
            |m: &CreateAuthRequest| { &m.Apps },
            |m: &mut CreateAuthRequest| { &mut m.Apps },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateAuthRequest>(
            "CreateAuthRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateAuthRequest {
    const NAME: &'static str = "CreateAuthRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.UID = is.read_string()?;
                },
                18 => {
                    self.Apps.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.UID.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.UID);
        }
        for value in &self.Apps {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.UID.is_empty() {
            os.write_string(1, &self.UID)?;
        }
        for v in &self.Apps {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateAuthRequest {
        CreateAuthRequest::new()
    }

    fn clear(&mut self) {
        self.UID.clear();
        self.Apps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateAuthRequest {
        static instance: CreateAuthRequest = CreateAuthRequest {
            UID: ::std::string::String::new(),
            Apps: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateAuthRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateAuthRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateAuthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAuthRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.CreateAuthResponse)
pub struct CreateAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:scyna.CreateAuthResponse.Token)
    pub Token: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.CreateAuthResponse.Expired)
    pub Expired: u64,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.CreateAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateAuthResponse {
    fn default() -> &'a CreateAuthResponse {
        <CreateAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateAuthResponse {
    pub fn new() -> CreateAuthResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Token",
            |m: &CreateAuthResponse| { &m.Token },
            |m: &mut CreateAuthResponse| { &mut m.Token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Expired",
            |m: &CreateAuthResponse| { &m.Expired },
            |m: &mut CreateAuthResponse| { &mut m.Expired },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateAuthResponse>(
            "CreateAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateAuthResponse {
    const NAME: &'static str = "CreateAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Token = is.read_string()?;
                },
                16 => {
                    self.Expired = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Token);
        }
        if self.Expired != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Expired);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Token.is_empty() {
            os.write_string(1, &self.Token)?;
        }
        if self.Expired != 0 {
            os.write_uint64(2, self.Expired)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateAuthResponse {
        CreateAuthResponse::new()
    }

    fn clear(&mut self) {
        self.Token.clear();
        self.Expired = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateAuthResponse {
        static instance: CreateAuthResponse = CreateAuthResponse {
            Token: ::std::string::String::new(),
            Expired: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateAuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.GetAuthRequest)
pub struct GetAuthRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.GetAuthRequest.Token)
    pub Token: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.GetAuthRequest.App)
    pub App: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.GetAuthRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthRequest {
    fn default() -> &'a GetAuthRequest {
        <GetAuthRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthRequest {
    pub fn new() -> GetAuthRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Token",
            |m: &GetAuthRequest| { &m.Token },
            |m: &mut GetAuthRequest| { &mut m.Token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "App",
            |m: &GetAuthRequest| { &m.App },
            |m: &mut GetAuthRequest| { &mut m.App },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAuthRequest>(
            "GetAuthRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAuthRequest {
    const NAME: &'static str = "GetAuthRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Token = is.read_string()?;
                },
                18 => {
                    self.App = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Token);
        }
        if !self.App.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.App);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Token.is_empty() {
            os.write_string(1, &self.Token)?;
        }
        if !self.App.is_empty() {
            os.write_string(2, &self.App)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthRequest {
        GetAuthRequest::new()
    }

    fn clear(&mut self) {
        self.Token.clear();
        self.App.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthRequest {
        static instance: GetAuthRequest = GetAuthRequest {
            Token: ::std::string::String::new(),
            App: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAuthRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAuthRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAuthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.GetAuthResponse)
pub struct GetAuthResponse {
    // message fields
    // @@protoc_insertion_point(field:scyna.GetAuthResponse.Token)
    pub Token: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.GetAuthResponse.Expired)
    pub Expired: u64,
    // @@protoc_insertion_point(field:scyna.GetAuthResponse.UserID)
    pub UserID: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.GetAuthResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetAuthResponse {
    fn default() -> &'a GetAuthResponse {
        <GetAuthResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAuthResponse {
    pub fn new() -> GetAuthResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Token",
            |m: &GetAuthResponse| { &m.Token },
            |m: &mut GetAuthResponse| { &mut m.Token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Expired",
            |m: &GetAuthResponse| { &m.Expired },
            |m: &mut GetAuthResponse| { &mut m.Expired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UserID",
            |m: &GetAuthResponse| { &m.UserID },
            |m: &mut GetAuthResponse| { &mut m.UserID },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetAuthResponse>(
            "GetAuthResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetAuthResponse {
    const NAME: &'static str = "GetAuthResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Token = is.read_string()?;
                },
                16 => {
                    self.Expired = is.read_uint64()?;
                },
                26 => {
                    self.UserID = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Token.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Token);
        }
        if self.Expired != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Expired);
        }
        if !self.UserID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.UserID);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Token.is_empty() {
            os.write_string(1, &self.Token)?;
        }
        if self.Expired != 0 {
            os.write_uint64(2, self.Expired)?;
        }
        if !self.UserID.is_empty() {
            os.write_string(3, &self.UserID)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetAuthResponse {
        GetAuthResponse::new()
    }

    fn clear(&mut self) {
        self.Token.clear();
        self.Expired = 0;
        self.UserID.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetAuthResponse {
        static instance: GetAuthResponse = GetAuthResponse {
            Token: ::std::string::String::new(),
            Expired: 0,
            UserID: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetAuthResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetAuthResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetAuthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAuthResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:scyna.LogoutRequest)
pub struct LogoutRequest {
    // message fields
    // @@protoc_insertion_point(field:scyna.LogoutRequest.Organization)
    pub Organization: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.LogoutRequest.Secret)
    pub Secret: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.LogoutRequest.UserID)
    pub UserID: ::std::string::String,
    // @@protoc_insertion_point(field:scyna.LogoutRequest.Token)
    pub Token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:scyna.LogoutRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogoutRequest {
    fn default() -> &'a LogoutRequest {
        <LogoutRequest as ::protobuf::Message>::default_instance()
    }
}

impl LogoutRequest {
    pub fn new() -> LogoutRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Organization",
            |m: &LogoutRequest| { &m.Organization },
            |m: &mut LogoutRequest| { &mut m.Organization },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Secret",
            |m: &LogoutRequest| { &m.Secret },
            |m: &mut LogoutRequest| { &mut m.Secret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "UserID",
            |m: &LogoutRequest| { &m.UserID },
            |m: &mut LogoutRequest| { &mut m.UserID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Token",
            |m: &LogoutRequest| { &m.Token },
            |m: &mut LogoutRequest| { &mut m.Token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogoutRequest>(
            "LogoutRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogoutRequest {
    const NAME: &'static str = "LogoutRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.Organization = is.read_string()?;
                },
                18 => {
                    self.Secret = is.read_string()?;
                },
                26 => {
                    self.UserID = is.read_string()?;
                },
                34 => {
                    self.Token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.Organization.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Organization);
        }
        if !self.Secret.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Secret);
        }
        if !self.UserID.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.UserID);
        }
        if !self.Token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.Token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.Organization.is_empty() {
            os.write_string(1, &self.Organization)?;
        }
        if !self.Secret.is_empty() {
            os.write_string(2, &self.Secret)?;
        }
        if !self.UserID.is_empty() {
            os.write_string(3, &self.UserID)?;
        }
        if !self.Token.is_empty() {
            os.write_string(4, &self.Token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogoutRequest {
        LogoutRequest::new()
    }

    fn clear(&mut self) {
        self.Organization.clear();
        self.Secret.clear();
        self.UserID.clear();
        self.Token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogoutRequest {
        static instance: LogoutRequest = LogoutRequest {
            Organization: ::std::string::String::new(),
            Secret: ::std::string::String::new(),
            UserID: ::std::string::String::new(),
            Token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogoutRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogoutRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogoutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogoutRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cengine.proto\x12\x05scyna\"\xe9\x01\n\rConfiguration\x12\x18\n\x07\
    NatsUrl\x18\x01\x20\x01(\tR\x07NatsUrl\x12\"\n\x0cNatsUsername\x18\x02\
    \x20\x01(\tR\x0cNatsUsername\x12\"\n\x0cNatsPassword\x18\x03\x20\x01(\tR\
    \x0cNatsPassword\x12\x16\n\x06DBHost\x18\x04\x20\x01(\tR\x06DBHost\x12\
    \x1e\n\nDBUsername\x18\x05\x20\x01(\tR\nDBUsername\x12\x1e\n\nDBPassword\
    \x18\x06\x20\x01(\tR\nDBPassword\x12\x1e\n\nDBLocation\x18\x07\x20\x01(\
    \tR\nDBLocation\"F\n\x14CreateSessionRequest\x12\x16\n\x06Module\x18\x01\
    \x20\x01(\tR\x06Module\x12\x16\n\x06Secret\x18\x02\x20\x01(\tR\x06Secret\
    \"c\n\x15CreateSessionResponse\x12\x1c\n\tSessionID\x18\x01\x20\x01(\x04\
    R\tSessionID\x12,\n\x06Config\x18\x05\x20\x01(\x0b2\x14.scyna.Configurat\
    ionR\x06Config\"N\n\x10EndSessionSignal\x12\x0e\n\x02ID\x18\x01\x20\x01(\
    \x04R\x02ID\x12\x12\n\x04Code\x18\x02\x20\x01(\tR\x04Code\x12\x16\n\x06M\
    odule\x18\x03\x20\x01(\tR\x06Module\"=\n\x13UpdateSessionSignal\x12\x0e\
    \n\x02ID\x18\x01\x20\x01(\x04R\x02ID\x12\x16\n\x06Module\x18\x02\x20\x01\
    (\tR\x06Module\"\x0e\n\x0cGetIDRequest\"O\n\rGetIDResponse\x12\x16\n\x06\
    prefix\x18\x01\x20\x01(\rR\x06prefix\x12\x14\n\x05start\x18\x02\x20\x01(\
    \x04R\x05start\x12\x10\n\x03end\x18\x03\x20\x01(\x04R\x03end\"\x20\n\x0c\
    GetSNRequest\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\"O\n\rGetSNResp\
    onse\x12\x16\n\x06prefix\x18\x01\x20\x01(\rR\x06prefix\x12\x14\n\x05star\
    t\x18\x02\x20\x01(\x04R\x05start\x12\x10\n\x03end\x18\x03\x20\x01(\x04R\
    \x03end\"\x8c\x01\n\x10LogCreatedSignal\x12\x12\n\x04Time\x18\x01\x20\
    \x01(\x04R\x04Time\x12\x14\n\x05Level\x18\x02\x20\x01(\rR\x05Level\x12\
    \x12\n\x04Text\x18\x03\x20\x01(\tR\x04Text\x12\x0e\n\x02ID\x18\x04\x20\
    \x01(\x04R\x02ID\x12\x10\n\x03SEQ\x18\x05\x20\x01(\x04R\x03SEQ\x12\x18\n\
    \x07Session\x18\x06\x20\x01(\x08R\x07Session\"\xe6\x01\n\x12TraceCreated\
    Signal\x12\x0e\n\x02ID\x18\x01\x20\x01(\x04R\x02ID\x12\x1a\n\x08ParentID\
    \x18\x02\x20\x01(\x04R\x08ParentID\x12\x12\n\x04Type\x18\x03\x20\x01(\rR\
    \x04Type\x12\x12\n\x04Time\x18\x04\x20\x01(\x04R\x04Time\x12\x1a\n\x08Du\
    ration\x18\x05\x20\x01(\x04R\x08Duration\x12\x12\n\x04Path\x18\x06\x20\
    \x01(\tR\x04Path\x12\x16\n\x06Source\x18\x07\x20\x01(\tR\x06Source\x12\
    \x1c\n\tSessionID\x18\x08\x20\x01(\x04R\tSessionID\x12\x16\n\x06Status\
    \x18\t\x20\x01(\x05R\x06Status\"T\n\x10TagCreatedSignal\x12\x18\n\x07Tra\
    ceID\x18\x01\x20\x01(\x04R\x07TraceID\x12\x10\n\x03Key\x18\x02\x20\x01(\
    \tR\x03Key\x12\x14\n\x05Value\x18\x03\x20\x01(\tR\x05Value\"d\n\x12Endpo\
    intDoneSignal\x12\x18\n\x07TraceID\x18\x01\x20\x01(\x04R\x07TraceID\x12\
    \x1a\n\x08Response\x18\x02\x20\x01(\tR\x08Response\x12\x18\n\x07Request\
    \x18\x03\x20\x01(\tR\x07Request\"U\n\x13WriteSettingRequest\x12\x16\n\
    \x06Module\x18\x01\x20\x01(\tR\x06Module\x12\x10\n\x03Key\x18\x02\x20\
    \x01(\tR\x03Key\x12\x14\n\x05Value\x18\x03\x20\x01(\tR\x05Value\">\n\x12\
    ReadSettingRequest\x12\x16\n\x06Module\x18\x01\x20\x01(\tR\x06Module\x12\
    \x10\n\x03Key\x18\x02\x20\x01(\tR\x03Key\"+\n\x13ReadSettingResponse\x12\
    \x14\n\x05Value\x18\x01\x20\x01(\tR\x05Value\"V\n\x14SettingUpdatedSigna\
    l\x12\x16\n\x06Module\x18\x01\x20\x01(\tR\x06Module\x12\x10\n\x03Key\x18\
    \x02\x20\x01(\tR\x03Key\x12\x14\n\x05Value\x18\x03\x20\x01(\tR\x05Value\
    \"@\n\x14SettingRemovedSignal\x12\x16\n\x06Module\x18\x01\x20\x01(\tR\
    \x06Module\x12\x10\n\x03Key\x18\x02\x20\x01(\tR\x03Key\"@\n\x14RemoveSet\
    tingRequest\x12\x16\n\x06Module\x18\x01\x20\x01(\tR\x06Module\x12\x10\n\
    \x03Key\x18\x02\x20\x01(\tR\x03Key\"\x85\x02\n\x0fWriteCallSignal\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x04R\x02id\x12\x16\n\x06source\x18\x02\x20\
    \x01(\tR\x06source\x12\x1b\n\tcaller_id\x18\x03\x20\x01(\tR\x08callerId\
    \x12\x1d\n\nsession_id\x18\x04\x20\x01(\x04R\tsessionId\x12\x1a\n\x08dur\
    ation\x18\x05\x20\x01(\rR\x08duration\x12\x18\n\x07request\x18\x06\x20\
    \x01(\x0cR\x07request\x12\x1a\n\x08response\x18\x07\x20\x01(\x0cR\x08res\
    ponse\x12\x16\n\x06status\x18\x08\x20\x01(\rR\x06status\x12\x12\n\x04tim\
    e\x18\t\x20\x01(\x04R\x04time\x12\x10\n\x03day\x18\n\x20\x01(\rR\x03day\
    \"9\n\x11CreateAuthRequest\x12\x10\n\x03UID\x18\x01\x20\x01(\tR\x03UID\
    \x12\x12\n\x04Apps\x18\x02\x20\x03(\tR\x04Apps\"D\n\x12CreateAuthRespons\
    e\x12\x14\n\x05Token\x18\x01\x20\x01(\tR\x05Token\x12\x18\n\x07Expired\
    \x18\x02\x20\x01(\x04R\x07Expired\"8\n\x0eGetAuthRequest\x12\x14\n\x05To\
    ken\x18\x01\x20\x01(\tR\x05Token\x12\x10\n\x03App\x18\x02\x20\x01(\tR\
    \x03App\"Y\n\x0fGetAuthResponse\x12\x14\n\x05Token\x18\x01\x20\x01(\tR\
    \x05Token\x12\x18\n\x07Expired\x18\x02\x20\x01(\x04R\x07Expired\x12\x16\
    \n\x06UserID\x18\x03\x20\x01(\tR\x06UserID\"y\n\rLogoutRequest\x12\"\n\
    \x0cOrganization\x18\x01\x20\x01(\tR\x0cOrganization\x12\x16\n\x06Secret\
    \x18\x02\x20\x01(\tR\x06Secret\x12\x16\n\x06UserID\x18\x03\x20\x01(\tR\
    \x06UserID\x12\x14\n\x05Token\x18\x04\x20\x01(\tR\x05TokenB2\n\x0eio.scy\
    na.protoP\x01H\x02Z\x0e./;scyna_proto\xaa\x02\x0bscyna.protoJ\x903\n\x07\
    \x12\x05\0\0\xa8\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\x08\r\n\x08\n\x01\x08\x12\x03\x03\0(\n\t\n\x02\x08\x01\x12\
    \x03\x03\0(\n\x08\n\x01\x08\x12\x03\x04\0#\n\t\n\x02\x08\n\x12\x03\x04\0\
    #\n\x08\n\x01\x08\x12\x03\x05\0)\n\t\n\x02\x08%\x12\x03\x05\0)\n\x08\n\
    \x01\x08\x12\x03\x06\0!\n\t\n\x02\x08\t\x12\x03\x06\0!\n\x08\n\x01\x08\
    \x12\x03\x07\0&\n\t\n\x02\x08\x0b\x12\x03\x07\0&\n\n\n\x02\x04\0\x12\x04\
    \t\0\x11\x01\n\n\n\x03\x04\0\x01\x12\x03\t\x08\x15\n\x0b\n\x04\x04\0\x02\
    \0\x12\x03\n\x02\x15\n\r\n\x05\x04\0\x02\0\x04\x12\x04\n\x02\t\x17\n\x0c\
    \n\x05\x04\0\x02\0\x05\x12\x03\n\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\n\t\x10\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\n\x13\x14\n\x0b\n\x04\
    \x04\0\x02\x01\x12\x03\x0b\x02\x1a\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\
    \x0b\x02\n\x15\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x0b\x02\x08\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\x0b\t\x15\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x0b\x18\x19\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x0c\x02\x1a\n\r\n\
    \x05\x04\0\x02\x02\x04\x12\x04\x0c\x02\x0b\x1a\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03\x0c\x02\x08\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x0c\t\x15\
    \n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x0c\x18\x19\n\x0b\n\x04\x04\0\x02\
    \x03\x12\x03\r\x02\x14\n\r\n\x05\x04\0\x02\x03\x04\x12\x04\r\x02\x0c\x1a\
    \n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\r\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x03\x01\x12\x03\r\t\x0f\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\r\x12\x13\
    \n\x0b\n\x04\x04\0\x02\x04\x12\x03\x0e\x02\x18\n\r\n\x05\x04\0\x02\x04\
    \x04\x12\x04\x0e\x02\r\x14\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x0e\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x0e\t\x13\n\x0c\n\x05\x04\0\
    \x02\x04\x03\x12\x03\x0e\x16\x17\n\x0b\n\x04\x04\0\x02\x05\x12\x03\x0f\
    \x02\x18\n\r\n\x05\x04\0\x02\x05\x04\x12\x04\x0f\x02\x0e\x18\n\x0c\n\x05\
    \x04\0\x02\x05\x05\x12\x03\x0f\x02\x08\n\x0c\n\x05\x04\0\x02\x05\x01\x12\
    \x03\x0f\t\x13\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x0f\x16\x17\n\x0b\n\
    \x04\x04\0\x02\x06\x12\x03\x10\x02\x18\n\r\n\x05\x04\0\x02\x06\x04\x12\
    \x04\x10\x02\x0f\x18\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03\x10\x02\x08\n\
    \x0c\n\x05\x04\0\x02\x06\x01\x12\x03\x10\t\x13\n\x0c\n\x05\x04\0\x02\x06\
    \x03\x12\x03\x10\x16\x17\n\x13\n\x02\x04\x01\x12\x04\x14\0\x17\x01\x1a\
    \x07session\n\n\n\x03\x04\x01\x01\x12\x03\x14\x08\x1c\n\x0b\n\x04\x04\
    \x01\x02\0\x12\x03\x15\x02\x14\n\r\n\x05\x04\x01\x02\0\x04\x12\x04\x15\
    \x02\x14\x1e\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\x15\x02\x08\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03\x15\t\x0f\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03\x15\x12\x13\n\x0b\n\x04\x04\x01\x02\x01\x12\x03\x16\x02\x14\n\r\
    \n\x05\x04\x01\x02\x01\x04\x12\x04\x16\x02\x15\x14\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x03\x16\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03\
    \x16\t\x0f\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x16\x12\x13\n\n\n\x02\
    \x04\x02\x12\x04\x19\0\x1c\x01\n\n\n\x03\x04\x02\x01\x12\x03\x19\x08\x1d\
    \n\x0b\n\x04\x04\x02\x02\0\x12\x03\x1a\x02\x1e\n\r\n\x05\x04\x02\x02\0\
    \x04\x12\x04\x1a\x02\x19\x1f\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x1a\
    \x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x1a\x10\x19\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x03\x1a\x1c\x1d\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03\x1b\x02\x1b\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\x1b\x02\x1a\x1e\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x03\x1b\x02\x0f\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03\x1b\x10\x16\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\
    \x1b\x19\x1a\n\n\n\x02\x04\x03\x12\x04\x1e\0\"\x01\n\n\n\x03\x04\x03\x01\
    \x12\x03\x1e\x08\x18\n\x0b\n\x04\x04\x03\x02\0\x12\x03\x1f\x02\x10\n\r\n\
    \x05\x04\x03\x02\0\x04\x12\x04\x1f\x02\x1e\x1a\n\x0c\n\x05\x04\x03\x02\0\
    \x05\x12\x03\x1f\x02\x08\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03\x1f\t\x0b\
    \n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03\x1f\x0e\x0f\n\x0b\n\x04\x04\x03\
    \x02\x01\x12\x03\x20\x02\x12\n\r\n\x05\x04\x03\x02\x01\x04\x12\x04\x20\
    \x02\x1f\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\x20\x02\x08\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03\x20\t\r\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03\x20\x10\x11\n\x0b\n\x04\x04\x03\x02\x02\x12\x03!\x02\x14\n\r\n\
    \x05\x04\x03\x02\x02\x04\x12\x04!\x02\x20\x12\n\x0c\n\x05\x04\x03\x02\
    \x02\x05\x12\x03!\x02\x08\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03!\t\x0f\
    \n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03!\x12\x13\n\n\n\x02\x04\x04\x12\
    \x04$\0'\x01\n\n\n\x03\x04\x04\x01\x12\x03$\x08\x1b\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03%\x02\x10\n\r\n\x05\x04\x04\x02\0\x04\x12\x04%\x02$\x1d\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03%\x02\x08\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03%\t\x0b\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03%\x0e\x0f\n\x0b\
    \n\x04\x04\x04\x02\x01\x12\x03&\x02\x14\n\r\n\x05\x04\x04\x02\x01\x04\
    \x12\x04&\x02%\x10\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03&\x02\x08\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03&\t\x0f\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03&\x12\x13\n\x15\n\x02\x04\x05\x12\x04*\0+\x01\x1a\tGENER\
    ATOR\n\n\n\x03\x04\x05\x01\x12\x03*\x08\x14\n\n\n\x02\x04\x06\x12\x04-\0\
    1\x01\n\n\n\x03\x04\x06\x01\x12\x03-\x08\x15\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03.\x02\x14\n\r\n\x05\x04\x06\x02\0\x04\x12\x04.\x02-\x17\n\x0c\n\
    \x05\x04\x06\x02\0\x05\x12\x03.\x02\x08\n\x0c\n\x05\x04\x06\x02\0\x01\
    \x12\x03.\t\x0f\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03.\x12\x13\n\x0b\n\
    \x04\x04\x06\x02\x01\x12\x03/\x02\x13\n\r\n\x05\x04\x06\x02\x01\x04\x12\
    \x04/\x02.\x14\n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03/\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\x01\x01\x12\x03/\t\x0e\n\x0c\n\x05\x04\x06\x02\x01\x03\
    \x12\x03/\x11\x12\n\x0b\n\x04\x04\x06\x02\x02\x12\x030\x02\x11\n\r\n\x05\
    \x04\x06\x02\x02\x04\x12\x040\x02/\x13\n\x0c\n\x05\x04\x06\x02\x02\x05\
    \x12\x030\x02\x08\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x030\t\x0c\n\x0c\n\
    \x05\x04\x06\x02\x02\x03\x12\x030\x0f\x10\n\n\n\x02\x04\x07\x12\x043\05\
    \x01\n\n\n\x03\x04\x07\x01\x12\x033\x08\x14\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x034\x02\x11\n\r\n\x05\x04\x07\x02\0\x04\x12\x044\x023\x16\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x034\x02\x08\n\x0c\n\x05\x04\x07\x02\0\x01\
    \x12\x034\t\x0c\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x034\x0f\x10\n\n\n\x02\
    \x04\x08\x12\x047\0;\x01\n\n\n\x03\x04\x08\x01\x12\x037\x08\x15\n\x0b\n\
    \x04\x04\x08\x02\0\x12\x038\x02\x14\n\r\n\x05\x04\x08\x02\0\x04\x12\x048\
    \x027\x17\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x038\x02\x08\n\x0c\n\x05\x04\
    \x08\x02\0\x01\x12\x038\t\x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x038\x12\
    \x13\n\x0b\n\x04\x04\x08\x02\x01\x12\x039\x02\x13\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x049\x028\x14\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x039\x02\
    \x08\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x039\t\x0e\n\x0c\n\x05\x04\x08\
    \x02\x01\x03\x12\x039\x11\x12\n\x0b\n\x04\x04\x08\x02\x02\x12\x03:\x02\
    \x11\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04:\x029\x13\n\x0c\n\x05\x04\x08\
    \x02\x02\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03:\t\
    \x0c\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03:\x0f\x10\n\x0f\n\x02\x04\t\
    \x12\x04>\0E\x01\x1a\x03LOG\n\n\n\x03\x04\t\x01\x12\x03>\x08\x18\n\x0b\n\
    \x04\x04\t\x02\0\x12\x03?\x02\x12\n\r\n\x05\x04\t\x02\0\x04\x12\x04?\x02\
    >\x1a\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03?\x02\x08\n\x0c\n\x05\x04\t\x02\
    \0\x01\x12\x03?\t\r\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03?\x10\x11\n\x0b\n\
    \x04\x04\t\x02\x01\x12\x03@\x02\x13\n\r\n\x05\x04\t\x02\x01\x04\x12\x04@\
    \x02?\x12\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03@\x02\x08\n\x0c\n\x05\x04\
    \t\x02\x01\x01\x12\x03@\t\x0e\n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03@\x11\
    \x12\n\x0b\n\x04\x04\t\x02\x02\x12\x03A\x02\x12\n\r\n\x05\x04\t\x02\x02\
    \x04\x12\x04A\x02@\x13\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03A\x02\x08\n\
    \x0c\n\x05\x04\t\x02\x02\x01\x12\x03A\t\r\n\x0c\n\x05\x04\t\x02\x02\x03\
    \x12\x03A\x10\x11\n\x0b\n\x04\x04\t\x02\x03\x12\x03B\x02\x10\n\r\n\x05\
    \x04\t\x02\x03\x04\x12\x04B\x02A\x12\n\x0c\n\x05\x04\t\x02\x03\x05\x12\
    \x03B\x02\x08\n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03B\t\x0b\n\x0c\n\x05\
    \x04\t\x02\x03\x03\x12\x03B\x0e\x0f\n\x0b\n\x04\x04\t\x02\x04\x12\x03C\
    \x02\x11\n\r\n\x05\x04\t\x02\x04\x04\x12\x04C\x02B\x10\n\x0c\n\x05\x04\t\
    \x02\x04\x05\x12\x03C\x02\x08\n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03C\t\
    \x0c\n\x0c\n\x05\x04\t\x02\x04\x03\x12\x03C\x0f\x10\n\x0b\n\x04\x04\t\
    \x02\x05\x12\x03D\x02\x15\n\r\n\x05\x04\t\x02\x05\x04\x12\x04D\x02C\x11\
    \n\x0c\n\x05\x04\t\x02\x05\x05\x12\x03D\x02\x06\n\x0c\n\x05\x04\t\x02\
    \x05\x01\x12\x03D\t\x10\n\x0c\n\x05\x04\t\x02\x05\x03\x12\x03D\x13\x14\n\
    \n\n\x02\x04\n\x12\x04G\0Q\x01\n\n\n\x03\x04\n\x01\x12\x03G\x08\x1a\n\
    \x0b\n\x04\x04\n\x02\0\x12\x03H\x02\x10\n\r\n\x05\x04\n\x02\0\x04\x12\
    \x04H\x02G\x1c\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03H\x02\x08\n\x0c\n\x05\
    \x04\n\x02\0\x01\x12\x03H\t\x0b\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03H\x0e\
    \x0f\n\x0b\n\x04\x04\n\x02\x01\x12\x03I\x02\x16\n\r\n\x05\x04\n\x02\x01\
    \x04\x12\x04I\x02H\x10\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03I\x02\x08\n\
    \x0c\n\x05\x04\n\x02\x01\x01\x12\x03I\t\x11\n\x0c\n\x05\x04\n\x02\x01\
    \x03\x12\x03I\x14\x15\n\x0b\n\x04\x04\n\x02\x02\x12\x03J\x02\x12\n\r\n\
    \x05\x04\n\x02\x02\x04\x12\x04J\x02I\x16\n\x0c\n\x05\x04\n\x02\x02\x05\
    \x12\x03J\x02\x08\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03J\t\r\n\x0c\n\x05\
    \x04\n\x02\x02\x03\x12\x03J\x10\x11\n\x0b\n\x04\x04\n\x02\x03\x12\x03K\
    \x02\x12\n\r\n\x05\x04\n\x02\x03\x04\x12\x04K\x02J\x12\n\x0c\n\x05\x04\n\
    \x02\x03\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\n\x02\x03\x01\x12\x03K\t\r\
    \n\x0c\n\x05\x04\n\x02\x03\x03\x12\x03K\x10\x11\n\x0b\n\x04\x04\n\x02\
    \x04\x12\x03L\x02\x16\n\r\n\x05\x04\n\x02\x04\x04\x12\x04L\x02K\x12\n\
    \x0c\n\x05\x04\n\x02\x04\x05\x12\x03L\x02\x08\n\x0c\n\x05\x04\n\x02\x04\
    \x01\x12\x03L\t\x11\n\x0c\n\x05\x04\n\x02\x04\x03\x12\x03L\x14\x15\n\x0b\
    \n\x04\x04\n\x02\x05\x12\x03M\x02\x12\n\r\n\x05\x04\n\x02\x05\x04\x12\
    \x04M\x02L\x16\n\x0c\n\x05\x04\n\x02\x05\x05\x12\x03M\x02\x08\n\x0c\n\
    \x05\x04\n\x02\x05\x01\x12\x03M\t\r\n\x0c\n\x05\x04\n\x02\x05\x03\x12\
    \x03M\x10\x11\n\x0b\n\x04\x04\n\x02\x06\x12\x03N\x02\x14\n\r\n\x05\x04\n\
    \x02\x06\x04\x12\x04N\x02M\x12\n\x0c\n\x05\x04\n\x02\x06\x05\x12\x03N\
    \x02\x08\n\x0c\n\x05\x04\n\x02\x06\x01\x12\x03N\t\x0f\n\x0c\n\x05\x04\n\
    \x02\x06\x03\x12\x03N\x12\x13\n\x0b\n\x04\x04\n\x02\x07\x12\x03O\x02\x17\
    \n\r\n\x05\x04\n\x02\x07\x04\x12\x04O\x02N\x14\n\x0c\n\x05\x04\n\x02\x07\
    \x05\x12\x03O\x02\x08\n\x0c\n\x05\x04\n\x02\x07\x01\x12\x03O\t\x12\n\x0c\
    \n\x05\x04\n\x02\x07\x03\x12\x03O\x15\x16\n\x0b\n\x04\x04\n\x02\x08\x12\
    \x03P\x02\x14\n\r\n\x05\x04\n\x02\x08\x04\x12\x04P\x02O\x17\n\x0c\n\x05\
    \x04\n\x02\x08\x05\x12\x03P\x02\x07\n\x0c\n\x05\x04\n\x02\x08\x01\x12\
    \x03P\t\x0f\n\x0c\n\x05\x04\n\x02\x08\x03\x12\x03P\x12\x13\n\n\n\x02\x04\
    \x0b\x12\x04S\0W\x01\n\n\n\x03\x04\x0b\x01\x12\x03S\x08\x18\n\x0b\n\x04\
    \x04\x0b\x02\0\x12\x03T\x02\x15\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04T\x02\
    S\x1a\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03T\x02\x08\n\x0c\n\x05\x04\x0b\
    \x02\0\x01\x12\x03T\t\x10\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03T\x13\x14\
    \n\x0b\n\x04\x04\x0b\x02\x01\x12\x03U\x02\x11\n\r\n\x05\x04\x0b\x02\x01\
    \x04\x12\x04U\x02T\x15\n\x0c\n\x05\x04\x0b\x02\x01\x05\x12\x03U\x02\x08\
    \n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03U\t\x0c\n\x0c\n\x05\x04\x0b\x02\
    \x01\x03\x12\x03U\x0f\x10\n\x0b\n\x04\x04\x0b\x02\x02\x12\x03V\x02\x13\n\
    \r\n\x05\x04\x0b\x02\x02\x04\x12\x04V\x02U\x11\n\x0c\n\x05\x04\x0b\x02\
    \x02\x05\x12\x03V\x02\x08\n\x0c\n\x05\x04\x0b\x02\x02\x01\x12\x03V\t\x0e\
    \n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03V\x11\x12\n\n\n\x02\x04\x0c\x12\
    \x04Y\0]\x01\n\n\n\x03\x04\x0c\x01\x12\x03Y\x08\x1a\n\x0b\n\x04\x04\x0c\
    \x02\0\x12\x03Z\x02\x15\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04Z\x02Y\x1c\n\
    \x0c\n\x05\x04\x0c\x02\0\x05\x12\x03Z\x02\x08\n\x0c\n\x05\x04\x0c\x02\0\
    \x01\x12\x03Z\t\x10\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03Z\x13\x14\n\x0b\
    \n\x04\x04\x0c\x02\x01\x12\x03[\x02\x16\n\r\n\x05\x04\x0c\x02\x01\x04\
    \x12\x04[\x02Z\x15\n\x0c\n\x05\x04\x0c\x02\x01\x05\x12\x03[\x02\x08\n\
    \x0c\n\x05\x04\x0c\x02\x01\x01\x12\x03[\t\x11\n\x0c\n\x05\x04\x0c\x02\
    \x01\x03\x12\x03[\x14\x15\n\x0b\n\x04\x04\x0c\x02\x02\x12\x03\\\x02\x15\
    \n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\\\x02[\x16\n\x0c\n\x05\x04\x0c\
    \x02\x02\x05\x12\x03\\\x02\x08\n\x0c\n\x05\x04\x0c\x02\x02\x01\x12\x03\\\
    \t\x10\n\x0c\n\x05\x04\x0c\x02\x02\x03\x12\x03\\\x13\x14\n\x13\n\x02\x04\
    \r\x12\x04`\0d\x01\x1a\x07SETTING\n\n\n\x03\x04\r\x01\x12\x03`\x08\x1b\n\
    \x0b\n\x04\x04\r\x02\0\x12\x03a\x02\x14\n\r\n\x05\x04\r\x02\0\x04\x12\
    \x04a\x02`\x1d\n\x0c\n\x05\x04\r\x02\0\x05\x12\x03a\x02\x08\n\x0c\n\x05\
    \x04\r\x02\0\x01\x12\x03a\t\x0f\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03a\x12\
    \x13\n\x0b\n\x04\x04\r\x02\x01\x12\x03b\x02\x11\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04b\x02a\x14\n\x0c\n\x05\x04\r\x02\x01\x05\x12\x03b\x02\x08\n\
    \x0c\n\x05\x04\r\x02\x01\x01\x12\x03b\t\x0c\n\x0c\n\x05\x04\r\x02\x01\
    \x03\x12\x03b\x0f\x10\n\x0b\n\x04\x04\r\x02\x02\x12\x03c\x02\x13\n\r\n\
    \x05\x04\r\x02\x02\x04\x12\x04c\x02b\x11\n\x0c\n\x05\x04\r\x02\x02\x05\
    \x12\x03c\x02\x08\n\x0c\n\x05\x04\r\x02\x02\x01\x12\x03c\t\x0e\n\x0c\n\
    \x05\x04\r\x02\x02\x03\x12\x03c\x11\x12\n\n\n\x02\x04\x0e\x12\x04f\0i\
    \x01\n\n\n\x03\x04\x0e\x01\x12\x03f\x08\x1a\n\x0b\n\x04\x04\x0e\x02\0\
    \x12\x03g\x02\x14\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04g\x02f\x1c\n\x0c\n\
    \x05\x04\x0e\x02\0\x05\x12\x03g\x02\x08\n\x0c\n\x05\x04\x0e\x02\0\x01\
    \x12\x03g\t\x0f\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03g\x12\x13\n\x0b\n\
    \x04\x04\x0e\x02\x01\x12\x03h\x02\x11\n\r\n\x05\x04\x0e\x02\x01\x04\x12\
    \x04h\x02g\x14\n\x0c\n\x05\x04\x0e\x02\x01\x05\x12\x03h\x02\x08\n\x0c\n\
    \x05\x04\x0e\x02\x01\x01\x12\x03h\t\x0c\n\x0c\n\x05\x04\x0e\x02\x01\x03\
    \x12\x03h\x0f\x10\n\n\n\x02\x04\x0f\x12\x04k\0m\x01\n\n\n\x03\x04\x0f\
    \x01\x12\x03k\x08\x1b\n\x0b\n\x04\x04\x0f\x02\0\x12\x03l\x02\x13\n\r\n\
    \x05\x04\x0f\x02\0\x04\x12\x04l\x02k\x1d\n\x0c\n\x05\x04\x0f\x02\0\x05\
    \x12\x03l\x02\x08\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03l\t\x0e\n\x0c\n\
    \x05\x04\x0f\x02\0\x03\x12\x03l\x11\x12\n\n\n\x02\x04\x10\x12\x04o\0s\
    \x01\n\n\n\x03\x04\x10\x01\x12\x03o\x08\x1c\n\x0b\n\x04\x04\x10\x02\0\
    \x12\x03p\x02\x14\n\r\n\x05\x04\x10\x02\0\x04\x12\x04p\x02o\x1e\n\x0c\n\
    \x05\x04\x10\x02\0\x05\x12\x03p\x02\x08\n\x0c\n\x05\x04\x10\x02\0\x01\
    \x12\x03p\t\x0f\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03p\x12\x13\n\x0b\n\
    \x04\x04\x10\x02\x01\x12\x03q\x02\x11\n\r\n\x05\x04\x10\x02\x01\x04\x12\
    \x04q\x02p\x14\n\x0c\n\x05\x04\x10\x02\x01\x05\x12\x03q\x02\x08\n\x0c\n\
    \x05\x04\x10\x02\x01\x01\x12\x03q\t\x0c\n\x0c\n\x05\x04\x10\x02\x01\x03\
    \x12\x03q\x0f\x10\n\x0b\n\x04\x04\x10\x02\x02\x12\x03r\x02\x13\n\r\n\x05\
    \x04\x10\x02\x02\x04\x12\x04r\x02q\x11\n\x0c\n\x05\x04\x10\x02\x02\x05\
    \x12\x03r\x02\x08\n\x0c\n\x05\x04\x10\x02\x02\x01\x12\x03r\t\x0e\n\x0c\n\
    \x05\x04\x10\x02\x02\x03\x12\x03r\x11\x12\n\n\n\x02\x04\x11\x12\x04u\0x\
    \x01\n\n\n\x03\x04\x11\x01\x12\x03u\x08\x1c\n\x0b\n\x04\x04\x11\x02\0\
    \x12\x03v\x02\x14\n\r\n\x05\x04\x11\x02\0\x04\x12\x04v\x02u\x1e\n\x0c\n\
    \x05\x04\x11\x02\0\x05\x12\x03v\x02\x08\n\x0c\n\x05\x04\x11\x02\0\x01\
    \x12\x03v\t\x0f\n\x0c\n\x05\x04\x11\x02\0\x03\x12\x03v\x12\x13\n\x0b\n\
    \x04\x04\x11\x02\x01\x12\x03w\x02\x11\n\r\n\x05\x04\x11\x02\x01\x04\x12\
    \x04w\x02v\x14\n\x0c\n\x05\x04\x11\x02\x01\x05\x12\x03w\x02\x08\n\x0c\n\
    \x05\x04\x11\x02\x01\x01\x12\x03w\t\x0c\n\x0c\n\x05\x04\x11\x02\x01\x03\
    \x12\x03w\x0f\x10\n\n\n\x02\x04\x12\x12\x04z\0}\x01\n\n\n\x03\x04\x12\
    \x01\x12\x03z\x08\x1c\n\x0b\n\x04\x04\x12\x02\0\x12\x03{\x02\x14\n\r\n\
    \x05\x04\x12\x02\0\x04\x12\x04{\x02z\x1e\n\x0c\n\x05\x04\x12\x02\0\x05\
    \x12\x03{\x02\x08\n\x0c\n\x05\x04\x12\x02\0\x01\x12\x03{\t\x0f\n\x0c\n\
    \x05\x04\x12\x02\0\x03\x12\x03{\x12\x13\n\x0b\n\x04\x04\x12\x02\x01\x12\
    \x03|\x02\x11\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04|\x02{\x14\n\x0c\n\
    \x05\x04\x12\x02\x01\x05\x12\x03|\x02\x08\n\x0c\n\x05\x04\x12\x02\x01\
    \x01\x12\x03|\t\x0c\n\x0c\n\x05\x04\x12\x02\x01\x03\x12\x03|\x0f\x10\n\
    \x12\n\x02\x04\x13\x12\x06\x80\x01\0\x8b\x01\x01\x1a\x04CALL\n\x0b\n\x03\
    \x04\x13\x01\x12\x04\x80\x01\x08\x17\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \x81\x01\x02\x10\n\x0f\n\x05\x04\x13\x02\0\x04\x12\x06\x81\x01\x02\x80\
    \x01\x19\n\r\n\x05\x04\x13\x02\0\x05\x12\x04\x81\x01\x02\x08\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\x81\x01\t\x0b\n\r\n\x05\x04\x13\x02\0\x03\x12\
    \x04\x81\x01\x0e\x0f\n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x82\x01\x02\x14\
    \n\x0f\n\x05\x04\x13\x02\x01\x04\x12\x06\x82\x01\x02\x81\x01\x10\n\r\n\
    \x05\x04\x13\x02\x01\x05\x12\x04\x82\x01\x02\x08\n\r\n\x05\x04\x13\x02\
    \x01\x01\x12\x04\x82\x01\t\x0f\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x82\
    \x01\x12\x13\n\x0c\n\x04\x04\x13\x02\x02\x12\x04\x83\x01\x02\x17\n\x0f\n\
    \x05\x04\x13\x02\x02\x04\x12\x06\x83\x01\x02\x82\x01\x14\n\r\n\x05\x04\
    \x13\x02\x02\x05\x12\x04\x83\x01\x02\x08\n\r\n\x05\x04\x13\x02\x02\x01\
    \x12\x04\x83\x01\t\x12\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x83\x01\x15\
    \x16\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\x84\x01\x02\x18\n\x0f\n\x05\x04\
    \x13\x02\x03\x04\x12\x06\x84\x01\x02\x83\x01\x17\n\r\n\x05\x04\x13\x02\
    \x03\x05\x12\x04\x84\x01\x02\x08\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\
    \x84\x01\t\x13\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x84\x01\x16\x17\n\
    \x0c\n\x04\x04\x13\x02\x04\x12\x04\x85\x01\x02\x16\n\x0f\n\x05\x04\x13\
    \x02\x04\x04\x12\x06\x85\x01\x02\x84\x01\x18\n\r\n\x05\x04\x13\x02\x04\
    \x05\x12\x04\x85\x01\x02\x08\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\x85\
    \x01\t\x11\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\x85\x01\x14\x15\n\x0c\n\
    \x04\x04\x13\x02\x05\x12\x04\x86\x01\x02\x15\n\x0f\n\x05\x04\x13\x02\x05\
    \x04\x12\x06\x86\x01\x02\x85\x01\x16\n\r\n\x05\x04\x13\x02\x05\x05\x12\
    \x04\x86\x01\x02\x07\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\x86\x01\t\x10\
    \n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\x86\x01\x13\x14\n\x0c\n\x04\x04\
    \x13\x02\x06\x12\x04\x87\x01\x02\x16\n\x0f\n\x05\x04\x13\x02\x06\x04\x12\
    \x06\x87\x01\x02\x86\x01\x15\n\r\n\x05\x04\x13\x02\x06\x05\x12\x04\x87\
    \x01\x02\x07\n\r\n\x05\x04\x13\x02\x06\x01\x12\x04\x87\x01\t\x11\n\r\n\
    \x05\x04\x13\x02\x06\x03\x12\x04\x87\x01\x14\x15\n\x0c\n\x04\x04\x13\x02\
    \x07\x12\x04\x88\x01\x02\x14\n\x0f\n\x05\x04\x13\x02\x07\x04\x12\x06\x88\
    \x01\x02\x87\x01\x16\n\r\n\x05\x04\x13\x02\x07\x05\x12\x04\x88\x01\x02\
    \x08\n\r\n\x05\x04\x13\x02\x07\x01\x12\x04\x88\x01\t\x0f\n\r\n\x05\x04\
    \x13\x02\x07\x03\x12\x04\x88\x01\x12\x13\n\x0c\n\x04\x04\x13\x02\x08\x12\
    \x04\x89\x01\x02\x12\n\x0f\n\x05\x04\x13\x02\x08\x04\x12\x06\x89\x01\x02\
    \x88\x01\x14\n\r\n\x05\x04\x13\x02\x08\x05\x12\x04\x89\x01\x02\x08\n\r\n\
    \x05\x04\x13\x02\x08\x01\x12\x04\x89\x01\t\r\n\r\n\x05\x04\x13\x02\x08\
    \x03\x12\x04\x89\x01\x10\x11\n\x0c\n\x04\x04\x13\x02\t\x12\x04\x8a\x01\
    \x02\x12\n\x0f\n\x05\x04\x13\x02\t\x04\x12\x06\x8a\x01\x02\x89\x01\x12\n\
    \r\n\x05\x04\x13\x02\t\x05\x12\x04\x8a\x01\x02\x08\n\r\n\x05\x04\x13\x02\
    \t\x01\x12\x04\x8a\x01\t\x0c\n\r\n\x05\x04\x13\x02\t\x03\x12\x04\x8a\x01\
    \x0f\x11\n\x1c\n\x02\x04\x14\x12\x06\x8e\x01\0\x91\x01\x01\x1a\x0eAuthen\
    tication\n\x0b\n\x03\x04\x14\x01\x12\x04\x8e\x01\x08\x19\n\x0c\n\x04\x04\
    \x14\x02\0\x12\x04\x8f\x01\x02\x1a\n\x0f\n\x05\x04\x14\x02\0\x04\x12\x06\
    \x8f\x01\x02\x8e\x01\x1b\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\x8f\x01\x02\
    \x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x8f\x01\x12\x15\n\r\n\x05\x04\
    \x14\x02\0\x03\x12\x04\x8f\x01\x18\x19\n\x0c\n\x04\x04\x14\x02\x01\x12\
    \x04\x90\x01\x02\x1b\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x90\x01\x02\n\
    \n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\x90\x01\x0b\x11\n\r\n\x05\x04\x14\
    \x02\x01\x01\x12\x04\x90\x01\x12\x16\n\r\n\x05\x04\x14\x02\x01\x03\x12\
    \x04\x90\x01\x19\x1a\n\x0c\n\x02\x04\x15\x12\x06\x93\x01\0\x96\x01\x01\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\x93\x01\x08\x1a\n\x0c\n\x04\x04\x15\x02\0\
    \x12\x04\x94\x01\x02\x13\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\x94\x01\
    \x02\x93\x01\x1c\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x94\x01\x02\x08\n\r\
    \n\x05\x04\x15\x02\0\x01\x12\x04\x94\x01\t\x0e\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\x94\x01\x11\x12\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x95\x01\
    \x02\x15\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\x95\x01\x02\x94\x01\x13\
    \n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x95\x01\x02\x08\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\x95\x01\t\x10\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \x95\x01\x13\x14\n\x0c\n\x02\x04\x16\x12\x06\x98\x01\0\x9b\x01\x01\n\x0b\
    \n\x03\x04\x16\x01\x12\x04\x98\x01\x08\x16\n\x0c\n\x04\x04\x16\x02\0\x12\
    \x04\x99\x01\x02\x13\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\x99\x01\x02\
    \x98\x01\x18\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x99\x01\x02\x08\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\x99\x01\t\x0e\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\x99\x01\x11\x12\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\x9a\x01\x02\
    \x11\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\x9a\x01\x02\x99\x01\x13\n\r\
    \n\x05\x04\x16\x02\x01\x05\x12\x04\x9a\x01\x02\x08\n\r\n\x05\x04\x16\x02\
    \x01\x01\x12\x04\x9a\x01\t\x0c\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x9a\
    \x01\x0f\x10\n\x0c\n\x02\x04\x17\x12\x06\x9d\x01\0\xa1\x01\x01\n\x0b\n\
    \x03\x04\x17\x01\x12\x04\x9d\x01\x08\x17\n\x0c\n\x04\x04\x17\x02\0\x12\
    \x04\x9e\x01\x02\x13\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\x9e\x01\x02\
    \x9d\x01\x19\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x9e\x01\x02\x08\n\r\n\
    \x05\x04\x17\x02\0\x01\x12\x04\x9e\x01\t\x0e\n\r\n\x05\x04\x17\x02\0\x03\
    \x12\x04\x9e\x01\x11\x12\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\x9f\x01\x02\
    \x15\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\x9f\x01\x02\x9e\x01\x13\n\r\
    \n\x05\x04\x17\x02\x01\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\x9f\x01\t\x10\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\x9f\
    \x01\x13\x14\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xa0\x01\x02\x14\n\x0f\n\
    \x05\x04\x17\x02\x02\x04\x12\x06\xa0\x01\x02\x9f\x01\x15\n\r\n\x05\x04\
    \x17\x02\x02\x05\x12\x04\xa0\x01\x02\x08\n\r\n\x05\x04\x17\x02\x02\x01\
    \x12\x04\xa0\x01\t\x0f\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xa0\x01\x12\
    \x13\n\x0c\n\x02\x04\x18\x12\x06\xa3\x01\0\xa8\x01\x01\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\xa3\x01\x08\x15\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xa4\
    \x01\x02\x1a\n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\xa4\x01\x02\xa3\x01\
    \x17\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\
    \x18\x02\0\x01\x12\x04\xa4\x01\t\x15\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\
    \xa4\x01\x18\x19\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xa5\x01\x02\x14\n\
    \x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\xa5\x01\x02\xa4\x01\x1a\n\r\n\x05\
    \x04\x18\x02\x01\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x18\x02\x01\
    \x01\x12\x04\xa5\x01\t\x0f\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xa5\x01\
    \x12\x13\n\x0c\n\x04\x04\x18\x02\x02\x12\x04\xa6\x01\x02\x14\n\x0f\n\x05\
    \x04\x18\x02\x02\x04\x12\x06\xa6\x01\x02\xa5\x01\x14\n\r\n\x05\x04\x18\
    \x02\x02\x05\x12\x04\xa6\x01\x02\x08\n\r\n\x05\x04\x18\x02\x02\x01\x12\
    \x04\xa6\x01\t\x0f\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xa6\x01\x12\x13\
    \n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xa7\x01\x02\x13\n\x0f\n\x05\x04\x18\
    \x02\x03\x04\x12\x06\xa7\x01\x02\xa6\x01\x14\n\r\n\x05\x04\x18\x02\x03\
    \x05\x12\x04\xa7\x01\x02\x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xa7\
    \x01\t\x0e\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xa7\x01\x11\x12b\x06pro\
    to3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(25);
            messages.push(Configuration::generated_message_descriptor_data());
            messages.push(CreateSessionRequest::generated_message_descriptor_data());
            messages.push(CreateSessionResponse::generated_message_descriptor_data());
            messages.push(EndSessionSignal::generated_message_descriptor_data());
            messages.push(UpdateSessionSignal::generated_message_descriptor_data());
            messages.push(GetIDRequest::generated_message_descriptor_data());
            messages.push(GetIDResponse::generated_message_descriptor_data());
            messages.push(GetSNRequest::generated_message_descriptor_data());
            messages.push(GetSNResponse::generated_message_descriptor_data());
            messages.push(LogCreatedSignal::generated_message_descriptor_data());
            messages.push(TraceCreatedSignal::generated_message_descriptor_data());
            messages.push(TagCreatedSignal::generated_message_descriptor_data());
            messages.push(EndpointDoneSignal::generated_message_descriptor_data());
            messages.push(WriteSettingRequest::generated_message_descriptor_data());
            messages.push(ReadSettingRequest::generated_message_descriptor_data());
            messages.push(ReadSettingResponse::generated_message_descriptor_data());
            messages.push(SettingUpdatedSignal::generated_message_descriptor_data());
            messages.push(SettingRemovedSignal::generated_message_descriptor_data());
            messages.push(RemoveSettingRequest::generated_message_descriptor_data());
            messages.push(WriteCallSignal::generated_message_descriptor_data());
            messages.push(CreateAuthRequest::generated_message_descriptor_data());
            messages.push(CreateAuthResponse::generated_message_descriptor_data());
            messages.push(GetAuthRequest::generated_message_descriptor_data());
            messages.push(GetAuthResponse::generated_message_descriptor_data());
            messages.push(LogoutRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
